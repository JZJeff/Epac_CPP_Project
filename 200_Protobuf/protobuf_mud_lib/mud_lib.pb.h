// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mud_lib.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3010000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3010000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mud_5flib_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mud_5flib_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mud_5flib_2eproto;
namespace mud {
class character;
class characterDefaultTypeInternal;
extern characterDefaultTypeInternal _character_default_instance_;
class character_book;
class character_bookDefaultTypeInternal;
extern character_bookDefaultTypeInternal _character_book_default_instance_;
class enemy;
class enemyDefaultTypeInternal;
extern enemyDefaultTypeInternal _enemy_default_instance_;
class enemy_book;
class enemy_bookDefaultTypeInternal;
extern enemy_bookDefaultTypeInternal _enemy_book_default_instance_;
class enum_atribute_name;
class enum_atribute_nameDefaultTypeInternal;
extern enum_atribute_nameDefaultTypeInternal _enum_atribute_name_default_instance_;
class enum_character;
class enum_characterDefaultTypeInternal;
extern enum_characterDefaultTypeInternal _enum_character_default_instance_;
class enum_direction;
class enum_directionDefaultTypeInternal;
extern enum_directionDefaultTypeInternal _enum_direction_default_instance_;
class location;
class locationDefaultTypeInternal;
extern locationDefaultTypeInternal _location_default_instance_;
class player;
class playerDefaultTypeInternal;
extern playerDefaultTypeInternal _player_default_instance_;
class player_book;
class player_bookDefaultTypeInternal;
extern player_bookDefaultTypeInternal _player_book_default_instance_;
class tile;
class tileDefaultTypeInternal;
extern tileDefaultTypeInternal _tile_default_instance_;
class tile_book;
class tile_bookDefaultTypeInternal;
extern tile_bookDefaultTypeInternal _tile_book_default_instance_;
}  // namespace mud
PROTOBUF_NAMESPACE_OPEN
template<> ::mud::character* Arena::CreateMaybeMessage<::mud::character>(Arena*);
template<> ::mud::character_book* Arena::CreateMaybeMessage<::mud::character_book>(Arena*);
template<> ::mud::enemy* Arena::CreateMaybeMessage<::mud::enemy>(Arena*);
template<> ::mud::enemy_book* Arena::CreateMaybeMessage<::mud::enemy_book>(Arena*);
template<> ::mud::enum_atribute_name* Arena::CreateMaybeMessage<::mud::enum_atribute_name>(Arena*);
template<> ::mud::enum_character* Arena::CreateMaybeMessage<::mud::enum_character>(Arena*);
template<> ::mud::enum_direction* Arena::CreateMaybeMessage<::mud::enum_direction>(Arena*);
template<> ::mud::location* Arena::CreateMaybeMessage<::mud::location>(Arena*);
template<> ::mud::player* Arena::CreateMaybeMessage<::mud::player>(Arena*);
template<> ::mud::player_book* Arena::CreateMaybeMessage<::mud::player_book>(Arena*);
template<> ::mud::tile* Arena::CreateMaybeMessage<::mud::tile>(Arena*);
template<> ::mud::tile_book* Arena::CreateMaybeMessage<::mud::tile_book>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mud {

enum enum_character_character_state : int {
  enum_character_character_state_NONE = 0,
  enum_character_character_state_WALKING = 1,
  enum_character_character_state_COMBAT = 2,
  enum_character_character_state_enum_character_character_state_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  enum_character_character_state_enum_character_character_state_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool enum_character_character_state_IsValid(int value);
constexpr enum_character_character_state enum_character_character_state_character_state_MIN = enum_character_character_state_NONE;
constexpr enum_character_character_state enum_character_character_state_character_state_MAX = enum_character_character_state_COMBAT;
constexpr int enum_character_character_state_character_state_ARRAYSIZE = enum_character_character_state_character_state_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* enum_character_character_state_descriptor();
template<typename T>
inline const std::string& enum_character_character_state_Name(T enum_t_value) {
  static_assert(::std::is_same<T, enum_character_character_state>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function enum_character_character_state_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    enum_character_character_state_descriptor(), enum_t_value);
}
inline bool enum_character_character_state_Parse(
    const std::string& name, enum_character_character_state* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<enum_character_character_state>(
    enum_character_character_state_descriptor(), name, value);
}
enum enum_atribute_name_attribute_name : int {
  enum_atribute_name_attribute_name_LIFE = 0,
  enum_atribute_name_attribute_name_STRENGTH = 1,
  enum_atribute_name_attribute_name_AGILITY = 2,
  enum_atribute_name_attribute_name_INTELLIGENCE = 3,
  enum_atribute_name_attribute_name_enum_atribute_name_attribute_name_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  enum_atribute_name_attribute_name_enum_atribute_name_attribute_name_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool enum_atribute_name_attribute_name_IsValid(int value);
constexpr enum_atribute_name_attribute_name enum_atribute_name_attribute_name_attribute_name_MIN = enum_atribute_name_attribute_name_LIFE;
constexpr enum_atribute_name_attribute_name enum_atribute_name_attribute_name_attribute_name_MAX = enum_atribute_name_attribute_name_INTELLIGENCE;
constexpr int enum_atribute_name_attribute_name_attribute_name_ARRAYSIZE = enum_atribute_name_attribute_name_attribute_name_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* enum_atribute_name_attribute_name_descriptor();
template<typename T>
inline const std::string& enum_atribute_name_attribute_name_Name(T enum_t_value) {
  static_assert(::std::is_same<T, enum_atribute_name_attribute_name>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function enum_atribute_name_attribute_name_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    enum_atribute_name_attribute_name_descriptor(), enum_t_value);
}
inline bool enum_atribute_name_attribute_name_Parse(
    const std::string& name, enum_atribute_name_attribute_name* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<enum_atribute_name_attribute_name>(
    enum_atribute_name_attribute_name_descriptor(), name, value);
}
enum enum_direction_direction : int {
  enum_direction_direction_NORTH = 0,
  enum_direction_direction_SOUTH = 1,
  enum_direction_direction_EAST = 2,
  enum_direction_direction_WEST = 3,
  enum_direction_direction_enum_direction_direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  enum_direction_direction_enum_direction_direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool enum_direction_direction_IsValid(int value);
constexpr enum_direction_direction enum_direction_direction_direction_MIN = enum_direction_direction_NORTH;
constexpr enum_direction_direction enum_direction_direction_direction_MAX = enum_direction_direction_WEST;
constexpr int enum_direction_direction_direction_ARRAYSIZE = enum_direction_direction_direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* enum_direction_direction_descriptor();
template<typename T>
inline const std::string& enum_direction_direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, enum_direction_direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function enum_direction_direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    enum_direction_direction_descriptor(), enum_t_value);
}
inline bool enum_direction_direction_Parse(
    const std::string& name, enum_direction_direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<enum_direction_direction>(
    enum_direction_direction_descriptor(), name, value);
}
enum tile_type : int {
  EMPTY = 0,
  WALL = 1,
  TREE = 2,
  PORTAL = 3,
  tile_type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  tile_type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool tile_type_IsValid(int value);
constexpr tile_type tile_type_MIN = EMPTY;
constexpr tile_type tile_type_MAX = PORTAL;
constexpr int tile_type_ARRAYSIZE = tile_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* tile_type_descriptor();
template<typename T>
inline const std::string& tile_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, tile_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function tile_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    tile_type_descriptor(), enum_t_value);
}
inline bool tile_type_Parse(
    const std::string& name, tile_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<tile_type>(
    tile_type_descriptor(), name, value);
}
enum resident_type : int {
  NOBODY = 0,
  CHARACTER = 1,
  ENEMY = 2,
  resident_type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  resident_type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool resident_type_IsValid(int value);
constexpr resident_type resident_type_MIN = NOBODY;
constexpr resident_type resident_type_MAX = ENEMY;
constexpr int resident_type_ARRAYSIZE = resident_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* resident_type_descriptor();
template<typename T>
inline const std::string& resident_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, resident_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function resident_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    resident_type_descriptor(), enum_t_value);
}
inline bool resident_type_Parse(
    const std::string& name, resident_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<resident_type>(
    resident_type_descriptor(), name, value);
}
// ===================================================================

class player :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.player) */ {
 public:
  player();
  virtual ~player();

  player(const player& from);
  player(player&& from) noexcept
    : player() {
    *this = ::std::move(from);
  }

  inline player& operator=(const player& from) {
    CopyFrom(from);
    return *this;
  }
  inline player& operator=(player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const player* internal_default_instance() {
    return reinterpret_cast<const player*>(
               &_player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(player& a, player& b) {
    a.Swap(&b);
  }
  inline void Swap(player* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline player* New() const final {
    return CreateMaybeMessage<player>(nullptr);
  }

  player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const player& from);
  void MergeFrom(const player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.player";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdCharactersFieldNumber = 4,
    kNameFieldNumber = 1,
    kPasswordHashFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // repeated int64 id_characters = 4;
  int id_characters_size() const;
  private:
  int _internal_id_characters_size() const;
  public:
  void clear_id_characters();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_characters(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_id_characters() const;
  void _internal_add_id_characters(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_id_characters();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 id_characters(int index) const;
  void set_id_characters(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_id_characters(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      id_characters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_id_characters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string password_hash = 2;
  void clear_password_hash();
  const std::string& password_hash() const;
  void set_password_hash(const std::string& value);
  void set_password_hash(std::string&& value);
  void set_password_hash(const char* value);
  void set_password_hash(const char* value, size_t size);
  std::string* mutable_password_hash();
  std::string* release_password_hash();
  void set_allocated_password_hash(std::string* password_hash);
  private:
  const std::string& _internal_password_hash() const;
  void _internal_set_password_hash(const std::string& value);
  std::string* _internal_mutable_password_hash();
  public:

  // int64 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.player)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > id_characters_;
  mutable std::atomic<int> _id_characters_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class player_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.player_book) */ {
 public:
  player_book();
  virtual ~player_book();

  player_book(const player_book& from);
  player_book(player_book&& from) noexcept
    : player_book() {
    *this = ::std::move(from);
  }

  inline player_book& operator=(const player_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline player_book& operator=(player_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const player_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const player_book* internal_default_instance() {
    return reinterpret_cast<const player_book*>(
               &_player_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(player_book& a, player_book& b) {
    a.Swap(&b);
  }
  inline void Swap(player_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline player_book* New() const final {
    return CreateMaybeMessage<player_book>(nullptr);
  }

  player_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<player_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const player_book& from);
  void MergeFrom(const player_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(player_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.player_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .mud.player players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::mud::player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >*
      mutable_players();
  private:
  const ::mud::player& _internal_players(int index) const;
  ::mud::player* _internal_add_players();
  public:
  const ::mud::player& players(int index) const;
  ::mud::player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >&
      players() const;

  // @@protoc_insertion_point(class_scope:mud.player_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enum_character :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enum_character) */ {
 public:
  enum_character();
  virtual ~enum_character();

  enum_character(const enum_character& from);
  enum_character(enum_character&& from) noexcept
    : enum_character() {
    *this = ::std::move(from);
  }

  inline enum_character& operator=(const enum_character& from) {
    CopyFrom(from);
    return *this;
  }
  inline enum_character& operator=(enum_character&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enum_character& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enum_character* internal_default_instance() {
    return reinterpret_cast<const enum_character*>(
               &_enum_character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(enum_character& a, enum_character& b) {
    a.Swap(&b);
  }
  inline void Swap(enum_character* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enum_character* New() const final {
    return CreateMaybeMessage<enum_character>(nullptr);
  }

  enum_character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enum_character>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enum_character& from);
  void MergeFrom(const enum_character& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enum_character* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enum_character";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef enum_character_character_state character_state;
  static constexpr character_state NONE =
    enum_character_character_state_NONE;
  static constexpr character_state WALKING =
    enum_character_character_state_WALKING;
  static constexpr character_state COMBAT =
    enum_character_character_state_COMBAT;
  static inline bool character_state_IsValid(int value) {
    return enum_character_character_state_IsValid(value);
  }
  static constexpr character_state character_state_MIN =
    enum_character_character_state_character_state_MIN;
  static constexpr character_state character_state_MAX =
    enum_character_character_state_character_state_MAX;
  static constexpr int character_state_ARRAYSIZE =
    enum_character_character_state_character_state_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  character_state_descriptor() {
    return enum_character_character_state_descriptor();
  }
  template<typename T>
  static inline const std::string& character_state_Name(T enum_t_value) {
    static_assert(::std::is_same<T, character_state>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function character_state_Name.");
    return enum_character_character_state_Name(enum_t_value);
  }
  static inline bool character_state_Parse(const std::string& name,
      character_state* value) {
    return enum_character_character_state_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mud.enum_character)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enum_atribute_name :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enum_atribute_name) */ {
 public:
  enum_atribute_name();
  virtual ~enum_atribute_name();

  enum_atribute_name(const enum_atribute_name& from);
  enum_atribute_name(enum_atribute_name&& from) noexcept
    : enum_atribute_name() {
    *this = ::std::move(from);
  }

  inline enum_atribute_name& operator=(const enum_atribute_name& from) {
    CopyFrom(from);
    return *this;
  }
  inline enum_atribute_name& operator=(enum_atribute_name&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enum_atribute_name& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enum_atribute_name* internal_default_instance() {
    return reinterpret_cast<const enum_atribute_name*>(
               &_enum_atribute_name_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(enum_atribute_name& a, enum_atribute_name& b) {
    a.Swap(&b);
  }
  inline void Swap(enum_atribute_name* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enum_atribute_name* New() const final {
    return CreateMaybeMessage<enum_atribute_name>(nullptr);
  }

  enum_atribute_name* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enum_atribute_name>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enum_atribute_name& from);
  void MergeFrom(const enum_atribute_name& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enum_atribute_name* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enum_atribute_name";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef enum_atribute_name_attribute_name attribute_name;
  static constexpr attribute_name LIFE =
    enum_atribute_name_attribute_name_LIFE;
  static constexpr attribute_name STRENGTH =
    enum_atribute_name_attribute_name_STRENGTH;
  static constexpr attribute_name AGILITY =
    enum_atribute_name_attribute_name_AGILITY;
  static constexpr attribute_name INTELLIGENCE =
    enum_atribute_name_attribute_name_INTELLIGENCE;
  static inline bool attribute_name_IsValid(int value) {
    return enum_atribute_name_attribute_name_IsValid(value);
  }
  static constexpr attribute_name attribute_name_MIN =
    enum_atribute_name_attribute_name_attribute_name_MIN;
  static constexpr attribute_name attribute_name_MAX =
    enum_atribute_name_attribute_name_attribute_name_MAX;
  static constexpr int attribute_name_ARRAYSIZE =
    enum_atribute_name_attribute_name_attribute_name_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  attribute_name_descriptor() {
    return enum_atribute_name_attribute_name_descriptor();
  }
  template<typename T>
  static inline const std::string& attribute_name_Name(T enum_t_value) {
    static_assert(::std::is_same<T, attribute_name>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function attribute_name_Name.");
    return enum_atribute_name_attribute_name_Name(enum_t_value);
  }
  static inline bool attribute_name_Parse(const std::string& name,
      attribute_name* value) {
    return enum_atribute_name_attribute_name_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mud.enum_atribute_name)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enum_direction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enum_direction) */ {
 public:
  enum_direction();
  virtual ~enum_direction();

  enum_direction(const enum_direction& from);
  enum_direction(enum_direction&& from) noexcept
    : enum_direction() {
    *this = ::std::move(from);
  }

  inline enum_direction& operator=(const enum_direction& from) {
    CopyFrom(from);
    return *this;
  }
  inline enum_direction& operator=(enum_direction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enum_direction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enum_direction* internal_default_instance() {
    return reinterpret_cast<const enum_direction*>(
               &_enum_direction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(enum_direction& a, enum_direction& b) {
    a.Swap(&b);
  }
  inline void Swap(enum_direction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enum_direction* New() const final {
    return CreateMaybeMessage<enum_direction>(nullptr);
  }

  enum_direction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enum_direction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enum_direction& from);
  void MergeFrom(const enum_direction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enum_direction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enum_direction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef enum_direction_direction direction;
  static constexpr direction NORTH =
    enum_direction_direction_NORTH;
  static constexpr direction SOUTH =
    enum_direction_direction_SOUTH;
  static constexpr direction EAST =
    enum_direction_direction_EAST;
  static constexpr direction WEST =
    enum_direction_direction_WEST;
  static inline bool direction_IsValid(int value) {
    return enum_direction_direction_IsValid(value);
  }
  static constexpr direction direction_MIN =
    enum_direction_direction_direction_MIN;
  static constexpr direction direction_MAX =
    enum_direction_direction_direction_MAX;
  static constexpr int direction_ARRAYSIZE =
    enum_direction_direction_direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  direction_descriptor() {
    return enum_direction_direction_descriptor();
  }
  template<typename T>
  static inline const std::string& direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function direction_Name.");
    return enum_direction_direction_Name(enum_t_value);
  }
  static inline bool direction_Parse(const std::string& name,
      direction* value) {
    return enum_direction_direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .mud.enum_direction.direction value = 1;
  void clear_value();
  ::mud::enum_direction_direction value() const;
  void set_value(::mud::enum_direction_direction value);
  private:
  ::mud::enum_direction_direction _internal_value() const;
  void _internal_set_value(::mud::enum_direction_direction value);
  public:

  // @@protoc_insertion_point(class_scope:mud.enum_direction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class character :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.character) */ {
 public:
  character();
  virtual ~character();

  character(const character& from);
  character(character&& from) noexcept
    : character() {
    *this = ::std::move(from);
  }

  inline character& operator=(const character& from) {
    CopyFrom(from);
    return *this;
  }
  inline character& operator=(character&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const character& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const character* internal_default_instance() {
    return reinterpret_cast<const character*>(
               &_character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(character& a, character& b) {
    a.Swap(&b);
  }
  inline void Swap(character* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline character* New() const final {
    return CreateMaybeMessage<character>(nullptr);
  }

  character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<character>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const character& from);
  void MergeFrom(const character& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(character* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.character";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kNameFieldNumber = 1,
    kFacingFieldNumber = 4,
    kStateFieldNumber = 6,
    kIdFieldNumber = 2,
    kTileIdFieldNumber = 3,
  };
  // repeated .mud.enum_atribute_name attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::mud::enum_atribute_name* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name >*
      mutable_attributes();
  private:
  const ::mud::enum_atribute_name& _internal_attributes(int index) const;
  ::mud::enum_atribute_name* _internal_add_attributes();
  public:
  const ::mud::enum_atribute_name& attributes(int index) const;
  ::mud::enum_atribute_name* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name >&
      attributes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mud.enum_direction facing = 4;
  bool has_facing() const;
  private:
  bool _internal_has_facing() const;
  public:
  void clear_facing();
  const ::mud::enum_direction& facing() const;
  ::mud::enum_direction* release_facing();
  ::mud::enum_direction* mutable_facing();
  void set_allocated_facing(::mud::enum_direction* facing);
  private:
  const ::mud::enum_direction& _internal_facing() const;
  ::mud::enum_direction* _internal_mutable_facing();
  public:

  // .mud.enum_character state = 6;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::mud::enum_character& state() const;
  ::mud::enum_character* release_state();
  ::mud::enum_character* mutable_state();
  void set_allocated_state(::mud::enum_character* state);
  private:
  const ::mud::enum_character& _internal_state() const;
  ::mud::enum_character* _internal_mutable_state();
  public:

  // int64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tile_id = 3;
  void clear_tile_id();
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id() const;
  void set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tile_id() const;
  void _internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.character)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name > attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mud::enum_direction* facing_;
  ::mud::enum_character* state_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enemy :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enemy) */ {
 public:
  enemy();
  virtual ~enemy();

  enemy(const enemy& from);
  enemy(enemy&& from) noexcept
    : enemy() {
    *this = ::std::move(from);
  }

  inline enemy& operator=(const enemy& from) {
    CopyFrom(from);
    return *this;
  }
  inline enemy& operator=(enemy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enemy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enemy* internal_default_instance() {
    return reinterpret_cast<const enemy*>(
               &_enemy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(enemy& a, enemy& b) {
    a.Swap(&b);
  }
  inline void Swap(enemy* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enemy* New() const final {
    return CreateMaybeMessage<enemy>(nullptr);
  }

  enemy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enemy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enemy& from);
  void MergeFrom(const enemy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enemy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enemy";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kNameFieldNumber = 1,
    kFacingFieldNumber = 4,
    kStateFieldNumber = 6,
    kIdFieldNumber = 2,
    kTileIdFieldNumber = 3,
  };
  // repeated .mud.enum_atribute_name attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::mud::enum_atribute_name* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name >*
      mutable_attributes();
  private:
  const ::mud::enum_atribute_name& _internal_attributes(int index) const;
  ::mud::enum_atribute_name* _internal_add_attributes();
  public:
  const ::mud::enum_atribute_name& attributes(int index) const;
  ::mud::enum_atribute_name* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name >&
      attributes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mud.enum_direction facing = 4;
  bool has_facing() const;
  private:
  bool _internal_has_facing() const;
  public:
  void clear_facing();
  const ::mud::enum_direction& facing() const;
  ::mud::enum_direction* release_facing();
  ::mud::enum_direction* mutable_facing();
  void set_allocated_facing(::mud::enum_direction* facing);
  private:
  const ::mud::enum_direction& _internal_facing() const;
  ::mud::enum_direction* _internal_mutable_facing();
  public:

  // .mud.enum_character state = 6;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::mud::enum_character& state() const;
  ::mud::enum_character* release_state();
  ::mud::enum_character* mutable_state();
  void set_allocated_state(::mud::enum_character* state);
  private:
  const ::mud::enum_character& _internal_state() const;
  ::mud::enum_character* _internal_mutable_state();
  public:

  // int64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tile_id = 3;
  void clear_tile_id();
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id() const;
  void set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tile_id() const;
  void _internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.enemy)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name > attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mud::enum_direction* facing_;
  ::mud::enum_character* state_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class character_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.character_book) */ {
 public:
  character_book();
  virtual ~character_book();

  character_book(const character_book& from);
  character_book(character_book&& from) noexcept
    : character_book() {
    *this = ::std::move(from);
  }

  inline character_book& operator=(const character_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline character_book& operator=(character_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const character_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const character_book* internal_default_instance() {
    return reinterpret_cast<const character_book*>(
               &_character_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(character_book& a, character_book& b) {
    a.Swap(&b);
  }
  inline void Swap(character_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline character_book* New() const final {
    return CreateMaybeMessage<character_book>(nullptr);
  }

  character_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<character_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const character_book& from);
  void MergeFrom(const character_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(character_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.character_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 1,
  };
  // repeated .mud.character characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::mud::character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
      mutable_characters();
  private:
  const ::mud::character& _internal_characters(int index) const;
  ::mud::character* _internal_add_characters();
  public:
  const ::mud::character& characters(int index) const;
  ::mud::character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
      characters() const;

  // @@protoc_insertion_point(class_scope:mud.character_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character > characters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enemy_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enemy_book) */ {
 public:
  enemy_book();
  virtual ~enemy_book();

  enemy_book(const enemy_book& from);
  enemy_book(enemy_book&& from) noexcept
    : enemy_book() {
    *this = ::std::move(from);
  }

  inline enemy_book& operator=(const enemy_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline enemy_book& operator=(enemy_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enemy_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enemy_book* internal_default_instance() {
    return reinterpret_cast<const enemy_book*>(
               &_enemy_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(enemy_book& a, enemy_book& b) {
    a.Swap(&b);
  }
  inline void Swap(enemy_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enemy_book* New() const final {
    return CreateMaybeMessage<enemy_book>(nullptr);
  }

  enemy_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enemy_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enemy_book& from);
  void MergeFrom(const enemy_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enemy_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enemy_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnemiesFieldNumber = 1,
  };
  // repeated .mud.enemy enemies = 1;
  int enemies_size() const;
  private:
  int _internal_enemies_size() const;
  public:
  void clear_enemies();
  ::mud::enemy* mutable_enemies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
      mutable_enemies();
  private:
  const ::mud::enemy& _internal_enemies(int index) const;
  ::mud::enemy* _internal_add_enemies();
  public:
  const ::mud::enemy& enemies(int index) const;
  ::mud::enemy* add_enemies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
      enemies() const;

  // @@protoc_insertion_point(class_scope:mud.enemy_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy > enemies_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class location :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.location) */ {
 public:
  location();
  virtual ~location();

  location(const location& from);
  location(location&& from) noexcept
    : location() {
    *this = ::std::move(from);
  }

  inline location& operator=(const location& from) {
    CopyFrom(from);
    return *this;
  }
  inline location& operator=(location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const location* internal_default_instance() {
    return reinterpret_cast<const location*>(
               &_location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(location& a, location& b) {
    a.Swap(&b);
  }
  inline void Swap(location* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline location* New() const final {
    return CreateMaybeMessage<location>(nullptr);
  }

  location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<location>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const location& from);
  void MergeFrom(const location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(location* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.location";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNorthFieldNumber = 1,
    kSouthFieldNumber = 2,
    kEastFieldNumber = 3,
    kWestFieldNumber = 4,
  };
  // int64 north = 1;
  void clear_north();
  ::PROTOBUF_NAMESPACE_ID::int64 north() const;
  void set_north(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_north() const;
  void _internal_set_north(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 south = 2;
  void clear_south();
  ::PROTOBUF_NAMESPACE_ID::int64 south() const;
  void set_south(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_south() const;
  void _internal_set_south(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 east = 3;
  void clear_east();
  ::PROTOBUF_NAMESPACE_ID::int64 east() const;
  void set_east(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_east() const;
  void _internal_set_east(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 west = 4;
  void clear_west();
  ::PROTOBUF_NAMESPACE_ID::int64 west() const;
  void set_west(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_west() const;
  void _internal_set_west(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.location)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 north_;
  ::PROTOBUF_NAMESPACE_ID::int64 south_;
  ::PROTOBUF_NAMESPACE_ID::int64 east_;
  ::PROTOBUF_NAMESPACE_ID::int64 west_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class tile :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.tile) */ {
 public:
  tile();
  virtual ~tile();

  tile(const tile& from);
  tile(tile&& from) noexcept
    : tile() {
    *this = ::std::move(from);
  }

  inline tile& operator=(const tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline tile& operator=(tile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tile* internal_default_instance() {
    return reinterpret_cast<const tile*>(
               &_tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(tile& a, tile& b) {
    a.Swap(&b);
  }
  inline void Swap(tile* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tile* New() const final {
    return CreateMaybeMessage<tile>(nullptr);
  }

  tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tile& from);
  void MergeFrom(const tile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.tile";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoodFieldNumber = 6,
    kNeighbourFieldNumber = 3,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kOccupantTypeFieldNumber = 4,
    kOccupantIdFieldNumber = 5,
  };
  // string mood = 6;
  void clear_mood();
  const std::string& mood() const;
  void set_mood(const std::string& value);
  void set_mood(std::string&& value);
  void set_mood(const char* value);
  void set_mood(const char* value, size_t size);
  std::string* mutable_mood();
  std::string* release_mood();
  void set_allocated_mood(std::string* mood);
  private:
  const std::string& _internal_mood() const;
  void _internal_set_mood(const std::string& value);
  std::string* _internal_mutable_mood();
  public:

  // .mud.location neighbour = 3;
  bool has_neighbour() const;
  private:
  bool _internal_has_neighbour() const;
  public:
  void clear_neighbour();
  const ::mud::location& neighbour() const;
  ::mud::location* release_neighbour();
  ::mud::location* mutable_neighbour();
  void set_allocated_neighbour(::mud::location* neighbour);
  private:
  const ::mud::location& _internal_neighbour() const;
  ::mud::location* _internal_mutable_neighbour();
  public:

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.tile_type type = 2;
  void clear_type();
  ::mud::tile_type type() const;
  void set_type(::mud::tile_type value);
  private:
  ::mud::tile_type _internal_type() const;
  void _internal_set_type(::mud::tile_type value);
  public:

  // .mud.resident_type occupant_type = 4;
  void clear_occupant_type();
  ::mud::resident_type occupant_type() const;
  void set_occupant_type(::mud::resident_type value);
  private:
  ::mud::resident_type _internal_occupant_type() const;
  void _internal_set_occupant_type(::mud::resident_type value);
  public:

  // int64 occupant_id = 5;
  void clear_occupant_id();
  ::PROTOBUF_NAMESPACE_ID::int64 occupant_id() const;
  void set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_occupant_id() const;
  void _internal_set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.tile)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mood_;
  ::mud::location* neighbour_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int type_;
  int occupant_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 occupant_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class tile_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.tile_book) */ {
 public:
  tile_book();
  virtual ~tile_book();

  tile_book(const tile_book& from);
  tile_book(tile_book&& from) noexcept
    : tile_book() {
    *this = ::std::move(from);
  }

  inline tile_book& operator=(const tile_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline tile_book& operator=(tile_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tile_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tile_book* internal_default_instance() {
    return reinterpret_cast<const tile_book*>(
               &_tile_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(tile_book& a, tile_book& b) {
    a.Swap(&b);
  }
  inline void Swap(tile_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tile_book* New() const final {
    return CreateMaybeMessage<tile_book>(nullptr);
  }

  tile_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tile_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tile_book& from);
  void MergeFrom(const tile_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tile_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.tile_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 1,
  };
  // repeated .mud.tile tiles = 1;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::mud::tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
      mutable_tiles();
  private:
  const ::mud::tile& _internal_tiles(int index) const;
  ::mud::tile* _internal_add_tiles();
  public:
  const ::mud::tile& tiles(int index) const;
  ::mud::tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
      tiles() const;

  // @@protoc_insertion_point(class_scope:mud.tile_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile > tiles_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// player

// string name = 1;
inline void player::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& player::name() const {
  // @@protoc_insertion_point(field_get:mud.player.name)
  return _internal_name();
}
inline void player::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.player.name)
}
inline std::string* player::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.player.name)
  return _internal_mutable_name();
}
inline const std::string& player::_internal_name() const {
  return name_.GetNoArena();
}
inline void player::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void player::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.player.name)
}
inline void player::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.player.name)
}
inline void player::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.player.name)
}
inline std::string* player::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* player::release_name() {
  // @@protoc_insertion_point(field_release:mud.player.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.player.name)
}

// string password_hash = 2;
inline void player::clear_password_hash() {
  password_hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& player::password_hash() const {
  // @@protoc_insertion_point(field_get:mud.player.password_hash)
  return _internal_password_hash();
}
inline void player::set_password_hash(const std::string& value) {
  _internal_set_password_hash(value);
  // @@protoc_insertion_point(field_set:mud.player.password_hash)
}
inline std::string* player::mutable_password_hash() {
  // @@protoc_insertion_point(field_mutable:mud.player.password_hash)
  return _internal_mutable_password_hash();
}
inline const std::string& player::_internal_password_hash() const {
  return password_hash_.GetNoArena();
}
inline void player::_internal_set_password_hash(const std::string& value) {
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void player::set_password_hash(std::string&& value) {
  
  password_hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.player.password_hash)
}
inline void player::set_password_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.player.password_hash)
}
inline void player::set_password_hash(const char* value, size_t size) {
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.player.password_hash)
}
inline std::string* player::_internal_mutable_password_hash() {
  
  return password_hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* player::release_password_hash() {
  // @@protoc_insertion_point(field_release:mud.player.password_hash)
  
  return password_hash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void player::set_allocated_password_hash(std::string* password_hash) {
  if (password_hash != nullptr) {
    
  } else {
    
  }
  password_hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password_hash);
  // @@protoc_insertion_point(field_set_allocated:mud.player.password_hash)
}

// int64 id = 3;
inline void player::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::id() const {
  // @@protoc_insertion_point(field_get:mud.player.id)
  return _internal_id();
}
inline void player::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void player::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.player.id)
}

// repeated int64 id_characters = 4;
inline int player::_internal_id_characters_size() const {
  return id_characters_.size();
}
inline int player::id_characters_size() const {
  return _internal_id_characters_size();
}
inline void player::clear_id_characters() {
  id_characters_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::_internal_id_characters(int index) const {
  return id_characters_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::id_characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.player.id_characters)
  return _internal_id_characters(index);
}
inline void player::set_id_characters(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  id_characters_.Set(index, value);
  // @@protoc_insertion_point(field_set:mud.player.id_characters)
}
inline void player::_internal_add_id_characters(::PROTOBUF_NAMESPACE_ID::int64 value) {
  id_characters_.Add(value);
}
inline void player::add_id_characters(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_id_characters(value);
  // @@protoc_insertion_point(field_add:mud.player.id_characters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
player::_internal_id_characters() const {
  return id_characters_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
player::id_characters() const {
  // @@protoc_insertion_point(field_list:mud.player.id_characters)
  return _internal_id_characters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
player::_internal_mutable_id_characters() {
  return &id_characters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
player::mutable_id_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.player.id_characters)
  return _internal_mutable_id_characters();
}

// -------------------------------------------------------------------

// player_book

// repeated .mud.player players = 1;
inline int player_book::_internal_players_size() const {
  return players_.size();
}
inline int player_book::players_size() const {
  return _internal_players_size();
}
inline void player_book::clear_players() {
  players_.Clear();
}
inline ::mud::player* player_book::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:mud.player_book.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >*
player_book::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:mud.player_book.players)
  return &players_;
}
inline const ::mud::player& player_book::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::mud::player& player_book::players(int index) const {
  // @@protoc_insertion_point(field_get:mud.player_book.players)
  return _internal_players(index);
}
inline ::mud::player* player_book::_internal_add_players() {
  return players_.Add();
}
inline ::mud::player* player_book::add_players() {
  // @@protoc_insertion_point(field_add:mud.player_book.players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >&
player_book::players() const {
  // @@protoc_insertion_point(field_list:mud.player_book.players)
  return players_;
}

// -------------------------------------------------------------------

// enum_character

// -------------------------------------------------------------------

// enum_atribute_name

// -------------------------------------------------------------------

// enum_direction

// .mud.enum_direction.direction value = 1;
inline void enum_direction::clear_value() {
  value_ = 0;
}
inline ::mud::enum_direction_direction enum_direction::_internal_value() const {
  return static_cast< ::mud::enum_direction_direction >(value_);
}
inline ::mud::enum_direction_direction enum_direction::value() const {
  // @@protoc_insertion_point(field_get:mud.enum_direction.value)
  return _internal_value();
}
inline void enum_direction::_internal_set_value(::mud::enum_direction_direction value) {
  
  value_ = value;
}
inline void enum_direction::set_value(::mud::enum_direction_direction value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mud.enum_direction.value)
}

// -------------------------------------------------------------------

// character

// string name = 1;
inline void character::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& character::name() const {
  // @@protoc_insertion_point(field_get:mud.character.name)
  return _internal_name();
}
inline void character::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.character.name)
}
inline std::string* character::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.character.name)
  return _internal_mutable_name();
}
inline const std::string& character::_internal_name() const {
  return name_.GetNoArena();
}
inline void character::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void character::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.character.name)
}
inline void character::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.character.name)
}
inline void character::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.character.name)
}
inline std::string* character::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* character::release_name() {
  // @@protoc_insertion_point(field_release:mud.character.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void character::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.character.name)
}

// int64 id = 2;
inline void character::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::id() const {
  // @@protoc_insertion_point(field_get:mud.character.id)
  return _internal_id();
}
inline void character::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void character::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.character.id)
}

// int64 tile_id = 3;
inline void character::clear_tile_id() {
  tile_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::_internal_tile_id() const {
  return tile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::tile_id() const {
  // @@protoc_insertion_point(field_get:mud.character.tile_id)
  return _internal_tile_id();
}
inline void character::_internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tile_id_ = value;
}
inline void character::set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tile_id(value);
  // @@protoc_insertion_point(field_set:mud.character.tile_id)
}

// .mud.enum_direction facing = 4;
inline bool character::_internal_has_facing() const {
  return this != internal_default_instance() && facing_ != nullptr;
}
inline bool character::has_facing() const {
  return _internal_has_facing();
}
inline void character::clear_facing() {
  if (GetArenaNoVirtual() == nullptr && facing_ != nullptr) {
    delete facing_;
  }
  facing_ = nullptr;
}
inline const ::mud::enum_direction& character::_internal_facing() const {
  const ::mud::enum_direction* p = facing_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::enum_direction*>(
      &::mud::_enum_direction_default_instance_);
}
inline const ::mud::enum_direction& character::facing() const {
  // @@protoc_insertion_point(field_get:mud.character.facing)
  return _internal_facing();
}
inline ::mud::enum_direction* character::release_facing() {
  // @@protoc_insertion_point(field_release:mud.character.facing)
  
  ::mud::enum_direction* temp = facing_;
  facing_ = nullptr;
  return temp;
}
inline ::mud::enum_direction* character::_internal_mutable_facing() {
  
  if (facing_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::enum_direction>(GetArenaNoVirtual());
    facing_ = p;
  }
  return facing_;
}
inline ::mud::enum_direction* character::mutable_facing() {
  // @@protoc_insertion_point(field_mutable:mud.character.facing)
  return _internal_mutable_facing();
}
inline void character::set_allocated_facing(::mud::enum_direction* facing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete facing_;
  }
  if (facing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      facing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, facing, submessage_arena);
    }
    
  } else {
    
  }
  facing_ = facing;
  // @@protoc_insertion_point(field_set_allocated:mud.character.facing)
}

// repeated .mud.enum_atribute_name attributes = 5;
inline int character::_internal_attributes_size() const {
  return attributes_.size();
}
inline int character::attributes_size() const {
  return _internal_attributes_size();
}
inline void character::clear_attributes() {
  attributes_.Clear();
}
inline ::mud::enum_atribute_name* character::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mud.character.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name >*
character::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mud.character.attributes)
  return &attributes_;
}
inline const ::mud::enum_atribute_name& character::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::mud::enum_atribute_name& character::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mud.character.attributes)
  return _internal_attributes(index);
}
inline ::mud::enum_atribute_name* character::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::mud::enum_atribute_name* character::add_attributes() {
  // @@protoc_insertion_point(field_add:mud.character.attributes)
  return _internal_add_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name >&
character::attributes() const {
  // @@protoc_insertion_point(field_list:mud.character.attributes)
  return attributes_;
}

// .mud.enum_character state = 6;
inline bool character::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool character::has_state() const {
  return _internal_has_state();
}
inline void character::clear_state() {
  if (GetArenaNoVirtual() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::mud::enum_character& character::_internal_state() const {
  const ::mud::enum_character* p = state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::enum_character*>(
      &::mud::_enum_character_default_instance_);
}
inline const ::mud::enum_character& character::state() const {
  // @@protoc_insertion_point(field_get:mud.character.state)
  return _internal_state();
}
inline ::mud::enum_character* character::release_state() {
  // @@protoc_insertion_point(field_release:mud.character.state)
  
  ::mud::enum_character* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::mud::enum_character* character::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::enum_character>(GetArenaNoVirtual());
    state_ = p;
  }
  return state_;
}
inline ::mud::enum_character* character::mutable_state() {
  // @@protoc_insertion_point(field_mutable:mud.character.state)
  return _internal_mutable_state();
}
inline void character::set_allocated_state(::mud::enum_character* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:mud.character.state)
}

// -------------------------------------------------------------------

// enemy

// string name = 1;
inline void enemy::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& enemy::name() const {
  // @@protoc_insertion_point(field_get:mud.enemy.name)
  return _internal_name();
}
inline void enemy::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.enemy.name)
}
inline std::string* enemy::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.enemy.name)
  return _internal_mutable_name();
}
inline const std::string& enemy::_internal_name() const {
  return name_.GetNoArena();
}
inline void enemy::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void enemy::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.enemy.name)
}
inline void enemy::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.enemy.name)
}
inline void enemy::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.enemy.name)
}
inline std::string* enemy::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* enemy::release_name() {
  // @@protoc_insertion_point(field_release:mud.enemy.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void enemy::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.enemy.name)
}

// int64 id = 2;
inline void enemy::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::id() const {
  // @@protoc_insertion_point(field_get:mud.enemy.id)
  return _internal_id();
}
inline void enemy::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void enemy::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.enemy.id)
}

// int64 tile_id = 3;
inline void enemy::clear_tile_id() {
  tile_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::_internal_tile_id() const {
  return tile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::tile_id() const {
  // @@protoc_insertion_point(field_get:mud.enemy.tile_id)
  return _internal_tile_id();
}
inline void enemy::_internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tile_id_ = value;
}
inline void enemy::set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tile_id(value);
  // @@protoc_insertion_point(field_set:mud.enemy.tile_id)
}

// .mud.enum_direction facing = 4;
inline bool enemy::_internal_has_facing() const {
  return this != internal_default_instance() && facing_ != nullptr;
}
inline bool enemy::has_facing() const {
  return _internal_has_facing();
}
inline void enemy::clear_facing() {
  if (GetArenaNoVirtual() == nullptr && facing_ != nullptr) {
    delete facing_;
  }
  facing_ = nullptr;
}
inline const ::mud::enum_direction& enemy::_internal_facing() const {
  const ::mud::enum_direction* p = facing_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::enum_direction*>(
      &::mud::_enum_direction_default_instance_);
}
inline const ::mud::enum_direction& enemy::facing() const {
  // @@protoc_insertion_point(field_get:mud.enemy.facing)
  return _internal_facing();
}
inline ::mud::enum_direction* enemy::release_facing() {
  // @@protoc_insertion_point(field_release:mud.enemy.facing)
  
  ::mud::enum_direction* temp = facing_;
  facing_ = nullptr;
  return temp;
}
inline ::mud::enum_direction* enemy::_internal_mutable_facing() {
  
  if (facing_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::enum_direction>(GetArenaNoVirtual());
    facing_ = p;
  }
  return facing_;
}
inline ::mud::enum_direction* enemy::mutable_facing() {
  // @@protoc_insertion_point(field_mutable:mud.enemy.facing)
  return _internal_mutable_facing();
}
inline void enemy::set_allocated_facing(::mud::enum_direction* facing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete facing_;
  }
  if (facing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      facing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, facing, submessage_arena);
    }
    
  } else {
    
  }
  facing_ = facing;
  // @@protoc_insertion_point(field_set_allocated:mud.enemy.facing)
}

// repeated .mud.enum_atribute_name attributes = 5;
inline int enemy::_internal_attributes_size() const {
  return attributes_.size();
}
inline int enemy::attributes_size() const {
  return _internal_attributes_size();
}
inline void enemy::clear_attributes() {
  attributes_.Clear();
}
inline ::mud::enum_atribute_name* enemy::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mud.enemy.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name >*
enemy::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mud.enemy.attributes)
  return &attributes_;
}
inline const ::mud::enum_atribute_name& enemy::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::mud::enum_atribute_name& enemy::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mud.enemy.attributes)
  return _internal_attributes(index);
}
inline ::mud::enum_atribute_name* enemy::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::mud::enum_atribute_name* enemy::add_attributes() {
  // @@protoc_insertion_point(field_add:mud.enemy.attributes)
  return _internal_add_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enum_atribute_name >&
enemy::attributes() const {
  // @@protoc_insertion_point(field_list:mud.enemy.attributes)
  return attributes_;
}

// .mud.enum_character state = 6;
inline bool enemy::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool enemy::has_state() const {
  return _internal_has_state();
}
inline void enemy::clear_state() {
  if (GetArenaNoVirtual() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::mud::enum_character& enemy::_internal_state() const {
  const ::mud::enum_character* p = state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::enum_character*>(
      &::mud::_enum_character_default_instance_);
}
inline const ::mud::enum_character& enemy::state() const {
  // @@protoc_insertion_point(field_get:mud.enemy.state)
  return _internal_state();
}
inline ::mud::enum_character* enemy::release_state() {
  // @@protoc_insertion_point(field_release:mud.enemy.state)
  
  ::mud::enum_character* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::mud::enum_character* enemy::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::enum_character>(GetArenaNoVirtual());
    state_ = p;
  }
  return state_;
}
inline ::mud::enum_character* enemy::mutable_state() {
  // @@protoc_insertion_point(field_mutable:mud.enemy.state)
  return _internal_mutable_state();
}
inline void enemy::set_allocated_state(::mud::enum_character* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:mud.enemy.state)
}

// -------------------------------------------------------------------

// character_book

// repeated .mud.character characters = 1;
inline int character_book::_internal_characters_size() const {
  return characters_.size();
}
inline int character_book::characters_size() const {
  return _internal_characters_size();
}
inline void character_book::clear_characters() {
  characters_.Clear();
}
inline ::mud::character* character_book::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:mud.character_book.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
character_book::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.character_book.characters)
  return &characters_;
}
inline const ::mud::character& character_book::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::mud::character& character_book::characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.character_book.characters)
  return _internal_characters(index);
}
inline ::mud::character* character_book::_internal_add_characters() {
  return characters_.Add();
}
inline ::mud::character* character_book::add_characters() {
  // @@protoc_insertion_point(field_add:mud.character_book.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
character_book::characters() const {
  // @@protoc_insertion_point(field_list:mud.character_book.characters)
  return characters_;
}

// -------------------------------------------------------------------

// enemy_book

// repeated .mud.enemy enemies = 1;
inline int enemy_book::_internal_enemies_size() const {
  return enemies_.size();
}
inline int enemy_book::enemies_size() const {
  return _internal_enemies_size();
}
inline void enemy_book::clear_enemies() {
  enemies_.Clear();
}
inline ::mud::enemy* enemy_book::mutable_enemies(int index) {
  // @@protoc_insertion_point(field_mutable:mud.enemy_book.enemies)
  return enemies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
enemy_book::mutable_enemies() {
  // @@protoc_insertion_point(field_mutable_list:mud.enemy_book.enemies)
  return &enemies_;
}
inline const ::mud::enemy& enemy_book::_internal_enemies(int index) const {
  return enemies_.Get(index);
}
inline const ::mud::enemy& enemy_book::enemies(int index) const {
  // @@protoc_insertion_point(field_get:mud.enemy_book.enemies)
  return _internal_enemies(index);
}
inline ::mud::enemy* enemy_book::_internal_add_enemies() {
  return enemies_.Add();
}
inline ::mud::enemy* enemy_book::add_enemies() {
  // @@protoc_insertion_point(field_add:mud.enemy_book.enemies)
  return _internal_add_enemies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
enemy_book::enemies() const {
  // @@protoc_insertion_point(field_list:mud.enemy_book.enemies)
  return enemies_;
}

// -------------------------------------------------------------------

// location

// int64 north = 1;
inline void location::clear_north() {
  north_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::_internal_north() const {
  return north_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::north() const {
  // @@protoc_insertion_point(field_get:mud.location.north)
  return _internal_north();
}
inline void location::_internal_set_north(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  north_ = value;
}
inline void location::set_north(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_north(value);
  // @@protoc_insertion_point(field_set:mud.location.north)
}

// int64 south = 2;
inline void location::clear_south() {
  south_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::_internal_south() const {
  return south_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::south() const {
  // @@protoc_insertion_point(field_get:mud.location.south)
  return _internal_south();
}
inline void location::_internal_set_south(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  south_ = value;
}
inline void location::set_south(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_south(value);
  // @@protoc_insertion_point(field_set:mud.location.south)
}

// int64 east = 3;
inline void location::clear_east() {
  east_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::_internal_east() const {
  return east_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::east() const {
  // @@protoc_insertion_point(field_get:mud.location.east)
  return _internal_east();
}
inline void location::_internal_set_east(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  east_ = value;
}
inline void location::set_east(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_east(value);
  // @@protoc_insertion_point(field_set:mud.location.east)
}

// int64 west = 4;
inline void location::clear_west() {
  west_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::_internal_west() const {
  return west_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::west() const {
  // @@protoc_insertion_point(field_get:mud.location.west)
  return _internal_west();
}
inline void location::_internal_set_west(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  west_ = value;
}
inline void location::set_west(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_west(value);
  // @@protoc_insertion_point(field_set:mud.location.west)
}

// -------------------------------------------------------------------

// tile

// int64 id = 1;
inline void tile::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::id() const {
  // @@protoc_insertion_point(field_get:mud.tile.id)
  return _internal_id();
}
inline void tile::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void tile::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.tile.id)
}

// .mud.tile_type type = 2;
inline void tile::clear_type() {
  type_ = 0;
}
inline ::mud::tile_type tile::_internal_type() const {
  return static_cast< ::mud::tile_type >(type_);
}
inline ::mud::tile_type tile::type() const {
  // @@protoc_insertion_point(field_get:mud.tile.type)
  return _internal_type();
}
inline void tile::_internal_set_type(::mud::tile_type value) {
  
  type_ = value;
}
inline void tile::set_type(::mud::tile_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mud.tile.type)
}

// .mud.location neighbour = 3;
inline bool tile::_internal_has_neighbour() const {
  return this != internal_default_instance() && neighbour_ != nullptr;
}
inline bool tile::has_neighbour() const {
  return _internal_has_neighbour();
}
inline void tile::clear_neighbour() {
  if (GetArenaNoVirtual() == nullptr && neighbour_ != nullptr) {
    delete neighbour_;
  }
  neighbour_ = nullptr;
}
inline const ::mud::location& tile::_internal_neighbour() const {
  const ::mud::location* p = neighbour_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::location*>(
      &::mud::_location_default_instance_);
}
inline const ::mud::location& tile::neighbour() const {
  // @@protoc_insertion_point(field_get:mud.tile.neighbour)
  return _internal_neighbour();
}
inline ::mud::location* tile::release_neighbour() {
  // @@protoc_insertion_point(field_release:mud.tile.neighbour)
  
  ::mud::location* temp = neighbour_;
  neighbour_ = nullptr;
  return temp;
}
inline ::mud::location* tile::_internal_mutable_neighbour() {
  
  if (neighbour_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::location>(GetArenaNoVirtual());
    neighbour_ = p;
  }
  return neighbour_;
}
inline ::mud::location* tile::mutable_neighbour() {
  // @@protoc_insertion_point(field_mutable:mud.tile.neighbour)
  return _internal_mutable_neighbour();
}
inline void tile::set_allocated_neighbour(::mud::location* neighbour) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete neighbour_;
  }
  if (neighbour) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      neighbour = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neighbour, submessage_arena);
    }
    
  } else {
    
  }
  neighbour_ = neighbour;
  // @@protoc_insertion_point(field_set_allocated:mud.tile.neighbour)
}

// .mud.resident_type occupant_type = 4;
inline void tile::clear_occupant_type() {
  occupant_type_ = 0;
}
inline ::mud::resident_type tile::_internal_occupant_type() const {
  return static_cast< ::mud::resident_type >(occupant_type_);
}
inline ::mud::resident_type tile::occupant_type() const {
  // @@protoc_insertion_point(field_get:mud.tile.occupant_type)
  return _internal_occupant_type();
}
inline void tile::_internal_set_occupant_type(::mud::resident_type value) {
  
  occupant_type_ = value;
}
inline void tile::set_occupant_type(::mud::resident_type value) {
  _internal_set_occupant_type(value);
  // @@protoc_insertion_point(field_set:mud.tile.occupant_type)
}

// int64 occupant_id = 5;
inline void tile::clear_occupant_id() {
  occupant_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::_internal_occupant_id() const {
  return occupant_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::occupant_id() const {
  // @@protoc_insertion_point(field_get:mud.tile.occupant_id)
  return _internal_occupant_id();
}
inline void tile::_internal_set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  occupant_id_ = value;
}
inline void tile::set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_occupant_id(value);
  // @@protoc_insertion_point(field_set:mud.tile.occupant_id)
}

// string mood = 6;
inline void tile::clear_mood() {
  mood_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& tile::mood() const {
  // @@protoc_insertion_point(field_get:mud.tile.mood)
  return _internal_mood();
}
inline void tile::set_mood(const std::string& value) {
  _internal_set_mood(value);
  // @@protoc_insertion_point(field_set:mud.tile.mood)
}
inline std::string* tile::mutable_mood() {
  // @@protoc_insertion_point(field_mutable:mud.tile.mood)
  return _internal_mutable_mood();
}
inline const std::string& tile::_internal_mood() const {
  return mood_.GetNoArena();
}
inline void tile::_internal_set_mood(const std::string& value) {
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void tile::set_mood(std::string&& value) {
  
  mood_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.tile.mood)
}
inline void tile::set_mood(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.tile.mood)
}
inline void tile::set_mood(const char* value, size_t size) {
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.tile.mood)
}
inline std::string* tile::_internal_mutable_mood() {
  
  return mood_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* tile::release_mood() {
  // @@protoc_insertion_point(field_release:mud.tile.mood)
  
  return mood_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void tile::set_allocated_mood(std::string* mood) {
  if (mood != nullptr) {
    
  } else {
    
  }
  mood_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mood);
  // @@protoc_insertion_point(field_set_allocated:mud.tile.mood)
}

// -------------------------------------------------------------------

// tile_book

// repeated .mud.tile tiles = 1;
inline int tile_book::_internal_tiles_size() const {
  return tiles_.size();
}
inline int tile_book::tiles_size() const {
  return _internal_tiles_size();
}
inline void tile_book::clear_tiles() {
  tiles_.Clear();
}
inline ::mud::tile* tile_book::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:mud.tile_book.tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
tile_book::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:mud.tile_book.tiles)
  return &tiles_;
}
inline const ::mud::tile& tile_book::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::mud::tile& tile_book::tiles(int index) const {
  // @@protoc_insertion_point(field_get:mud.tile_book.tiles)
  return _internal_tiles(index);
}
inline ::mud::tile* tile_book::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::mud::tile* tile_book::add_tiles() {
  // @@protoc_insertion_point(field_add:mud.tile_book.tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
tile_book::tiles() const {
  // @@protoc_insertion_point(field_list:mud.tile_book.tiles)
  return tiles_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mud

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mud::enum_character_character_state> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::enum_character_character_state>() {
  return ::mud::enum_character_character_state_descriptor();
}
template <> struct is_proto_enum< ::mud::enum_atribute_name_attribute_name> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::enum_atribute_name_attribute_name>() {
  return ::mud::enum_atribute_name_attribute_name_descriptor();
}
template <> struct is_proto_enum< ::mud::enum_direction_direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::enum_direction_direction>() {
  return ::mud::enum_direction_direction_descriptor();
}
template <> struct is_proto_enum< ::mud::tile_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::tile_type>() {
  return ::mud::tile_type_descriptor();
}
template <> struct is_proto_enum< ::mud::resident_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::resident_type>() {
  return ::mud::resident_type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto
